<!DOCTYPE html>
<html>
<head>
    <title>Infinite Platformer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let player = {
            x: 100, y: 100, width: 30, height: 40, velocityX: 0, velocityY: 0, jumping: false,
            frame: 0, animationSpeed: 10, alive: true
        };
        let camera = { x: 0, y: 0 };
        let world = { tiles: [] };
        let enemies = [];
        let killEffects = [];
        const gravity = 0.5;
        const jumpStrength = -12;
        const moveSpeed = 5;
        const worldTileWidth = 100;

        function generateWorld() {
            let startX = Math.floor(camera.x / worldTileWidth) * worldTileWidth;
            let endX = startX + canvas.width * 2;

            world.tiles = world.tiles.filter(tile => tile.x + tile.width > camera.x - canvas.width);

            for (let x = startX; x < endX; x += worldTileWidth) {
                if (!world.tiles.some(tile => tile.x === x)) {
                    let y = canvas.height - 50 - Math.random() * 150; // Increased height variation
                    let width = worldTileWidth;
                    let hasSpikes = Math.random() < 0.2; // 20% chance of spikes
                    world.tiles.push({ x: x, y: y, width: width, height: 50, spikes: hasSpikes });
                    x += worldTileWidth + 100 + Math.random() * 200; // Increased gap
                }
            }
        }

        function drawWorld() {
            world.tiles.forEach(tile => {
                ctx.fillStyle = 'gray';
                ctx.fillRect(tile.x - camera.x, tile.y - camera.y, tile.width, tile.height);
                if (tile.spikes) {
                    ctx.fillStyle = 'darkred';
                    ctx.beginPath();
                    ctx.moveTo(tile.x - camera.x + tile.width / 2, tile.y - camera.y);
                    ctx.lineTo(tile.x - camera.x, tile.y - camera.y + 20);
                    ctx.lineTo(tile.x - camera.x + tile.width, tile.y - camera.y + 20);
                    ctx.closePath();
                    ctx.fill();
                }
            });
        }

        function drawPlayer() {
            if (player.alive) {
                let frameX = (player.frame * player.width) % (player.width * 2);
                ctx.fillStyle = 'blue';
                ctx.fillRect(player.x - camera.x, player.y - camera.y, player.width, player.height);
            }
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                ctx.fillStyle = 'red';
                ctx.fillRect(enemy.x - camera.x, enemy.y - camera.y, 20, 30);
            });
        }

        function drawKillEffects() {
            killEffects.forEach(effect => {
                ctx.fillStyle = 'yellow';
                ctx.fillRect(effect.x - camera.x, effect.y - camera.y, 10, 10);
            });
        }

        function updatePlayer() {
            if (!player.alive) return;

            player.x += player.velocityX;
            player.y += player.velocityY;
            player.velocityY += gravity;

            world.tiles.forEach(tile => {
                if (player.x < tile.x + tile.width && player.x + player.width > tile.x &&
                    player.y < tile.y + tile.height && player.y + player.height > tile.y) {
                    let dx = (player.x + player.width / 2) - (tile.x + tile.width / 2);
                    let dy = (player.y + player.height / 2) - (tile.y + tile.height / 2);
                    let width = (player.width + tile.width) / 2;
                    let height = (player.height + tile.height) / 2;

                    if (Math.abs(dx) <= width && Math.abs(dy) <= height) {
                        let crossWidth = width * Math.abs(dy);
                        let crossHeight = height * Math.abs(dx);

                        if (crossWidth > crossHeight) {
                            if (dy > 0) {
                                player.y = tile.y + tile.height;
                                player.velocityY = 0;
                            } else {
                                player.y = tile.y - player.height;
                                player.velocityY = 0;
                                player.jumping = false;
                            }
                        } else {
                            if (dx > 0) {
                                player.x = tile.x + tile.width;
                            } else {
                                player.x = tile.x - player.width;
                            }
                        }
                    }
                }
                if (tile.spikes && player.x < tile.x + tile.width && player.x + player.width > tile.x &&
                    player.y + player.height > tile.y && player.y < tile.y + 20) {
                    player.alive = false;
                }
            });

            camera.x = player.x - canvas.width / 2;
            player.frame = (player.frame + 1) % player.animationSpeed;
            generateWorld();
        }

        // ... (rest of the code remains the same)

        document.addEventListener('keydown', (event) => {
            if (player.alive) {
                if (event.key === 'ArrowLeft') {
                    player.velocityX = -moveSpeed;
                } else if (event.key === 'ArrowRight') {
                    player.velocityX = moveSpeed;
                } else if (event.key === 'ArrowUp' && !player.jumping) {
                    player.velocityY = jumpStrength;
                    player.jumping = true;
                }
            }
            if (event.key === 'r') {
                player = { x: 100, y: 100, width: 30, height: 40, velocityX: 0, velocityY: 0, jumping: false, frame: 0, animationSpeed: 10, alive: true };
                camera = { x: 0, y: 0 };
                enemies = [];
                world = { tiles: [] };
                generateWorld();
            }
        });
    </script>
</body>
</html>
